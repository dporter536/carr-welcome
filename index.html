<script>
(async () => {
  const API = 'https://script.google.com/macros/s/AKfycby8ZTL2LoFxGjKrVHIsShHb1Z722mZxUvi0YyHXuuTgBEn2XCtMyfny7tvuEIzn0STAEg/exec';
  const params = new URLSearchParams(location.search);
  const cabinParam = params.get('cabin') || 'C1';
  const up = cabinParam.toUpperCase();
  const cabinLabel = up==='C1'?'Cabin 1':up==='C2'?'Cabin 2':up==='C3'?'Cabin 3':cabinParam;

  // --- fetch data ---
  try {
    const r = await fetch(`${API}?cabin=${encodeURIComponent(cabinParam)}&v=${Date.now()}`, { cache:'no-store' });
    const j = await r.json();

    const headline=document.getElementById('headline');
    const sub=document.getElementById('sub');
    const meta=document.getElementById('meta');
    const extra=document.getElementById('extra');
    document.getElementById('spin').style.display='none';

    const s=(n,w)=>n===1?w:w+'s';

    if (j.success && j.guestName) {
      const first=j.guestName.trim().split(/\s+/)[0];
      headline.textContent=`Welcome, ${first}!`;
      sub.textContent=`${cabinLabel} • ${j.dateISO}`;
      if (j.stayNight && j.nights && j.checkoutPretty) {
        meta.textContent=`Night ${j.stayNight} • Staying ${j.nights} ${s(j.nights,'night')} • Checkout ${j.checkoutPretty}`;
      } else if (j.nights && j.checkoutPretty) {
        meta.textContent=`Staying ${j.nights} ${s(j.nights,'night')} • Checkout ${j.checkoutPretty}`;
      } else {
        meta.textContent='We’re thrilled to host you. The hot tub is ready — have an amazing stay.';
      }
      extra.textContent='';
    } else if (j.success) {
      headline.textContent='Welcome to Carrick-a-Rede Retreat';
      sub.textContent=cabinLabel;
      meta.textContent=`Today: ${new Date().toLocaleDateString('en-GB')}`;
      extra.textContent=j.phase==='neutral_changeover' ? 'Housekeeping in progress — we’ll have everything perfect for your arrival.' : '';
    } else {
      meta.textContent='Unable to load booking details right now.';
    }
  } catch {
    document.getElementById('spin').style.display='none';
  }

  // --- robust video/slideshow control ---
  const video = document.getElementById('bgVideo');
  const slidesWrap = document.getElementById('slides');
  const slides = Array.from(slidesWrap.querySelectorAll('.slide'));
  let slideIdx = 0, slideTimer = null, backToVideoTimer = null;

  // Start with the slideshow visible as a safe default
  function startSlideshow() {
    video.classList.remove('visible');
    slidesWrap.classList.add('visible');
    slides.forEach(s=>s.classList.remove('active'));
    slideIdx = 0;
    slides[0].classList.add('active');
    clearInterval(slideTimer);
    slideTimer = setInterval(()=>{
      slides[slideIdx].classList.remove('active');
      slideIdx = (slideIdx + 1) % slides.length;
      slides[slideIdx].classList.add('active');
    }, 8000);
  }

  function showVideoThenReturn() {
    // Only switch to video if it has real frames (readyState>=2 and videoWidth>0)
    const hasFrames = () => video.readyState >= 2 && video.videoWidth > 0;
    const switchToVideo = () => {
      if (!hasFrames()) return; // guard
      slidesWrap.classList.remove('visible');
      video.classList.add('visible');
      try { video.currentTime = 0; video.play().catch(()=>{}); } catch(e){}
      const dur = (isFinite(video.duration) && video.duration > 2) ? video.duration*1000 : 30000;
      clearTimeout(backToVideoTimer);
      backToVideoTimer = setTimeout(startSlideshow, dur);
    };

    if (hasFrames()) switchToVideo();
    else {
      // wait for first decoded frame, then switch
      video.addEventListener('loadeddata', switchToVideo, { once:true });
      video.addEventListener('canplay', switchToVideo, { once:true });
      video.addEventListener('error', () => { /* stay on slideshow */ }, { once:true });
      try { video.play().catch(()=>{}); } catch(e){}
      // hard fallback: if still no frames after 8s, keep slideshow
      setTimeout(() => { if (!hasFrames()) {/* do nothing, slideshow stays */} }, 8000);
    }
  }

  startSlideshow();          // Show photos immediately
  showVideoThenReturn();     // Fade to video only if/when it’s actually decodable

  // --- scheduled refreshes + heartbeat ---
  function scheduleReloads(times){
    const now=new Date();
    for(const [h,m] of times){
      const t=new Date(); t.setHours(h,m,0,0);
      if(t<=now) t.setDate(t.getDate()+1);
      setTimeout(()=>location.reload(), t-now);
    }
  }
  setInterval(()=>location.reload(), 30*60*1000);  // heartbeat 30 min
  scheduleReloads([[7,28],[11,31],[14,31]]);
})();
</script>
